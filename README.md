obfuscators for anything needing to touch disk (download n exec, file share's etc).
offers a degree of evasion from signature based detection.

```
 gen-obfuscated.pl 
 
 creates an obfuscated vbs/vba downloader 

 Converts a character to it's ascii code value. Works as a 
 simple vb-s/a obfuscator specificly for shell command 
 execution. The current examples focus on powershell based 
 attacks but is not limited to them.

```

```

ps-obfuscator.ps1

Generates ofuscated vbs downloaders, also has functions with malware 
type behavior. Designed to be used with an implant.

Originally started out as gen-obfuscated which was written in perl. I wanted to 
rewrite that perl script from scratch but instead kinda did it in powershell.
This was due to having the implants being able to generate obfuscated payloads
on there own. 

Not all of the functions from gen-obfuscated have been moved over and some 
of this stuff is original and was never on the perl script to begin with.
The code here has been removed from the implants for stand alone use.
And are tailored for the idea of "user initiated" lateral movement inside 
a network. Which should help remove the need of exploits.

```

```
womp-womp.ps1

Originally intended to work on Invoke-Mimikatz when it needs to be copied 
to disk and AV keep flagging it. So instead of trying to find the string 
signature in the mimikatz ps1 I used this technique to pretty much make 
it a moot point.

Found this technique should work on most scripts after some porting.

When using the obfuscation option the file generated requires the use 
of launcher.ps1 for it to deobfuscate then execute it.
```

```
launcher.ps1 

Is needed to execute the obfuscated code generated by womp-womp.ps1. 
The launcher needs to be run in memory since it is vulnerable to detection.

For example use System.Net.Webclient or ps12bat_v3.ps1 to insulate the
plain text code from disk.

```

```
ps12bat.ps1 

This will base64 encode a ps1 script then embed it in a .bat file.
Upon execution it will create a hidden ascii file with the embeded encoded base64 string.
also creates .cmd file which will read and then execute the base 64 file and a userland 
registry run key that executes upon user login.

The idea behind this is when you have to copy to disk since you cannot use a webclient 
to download the entire code. This means you need to have it in a self contained 
manner, but not by using dll's or compiled binaries.

as log as you have enough access to get a .bat file to execute the rest should fall on
the quality of your powershell code.

Tested running a generated .bat file on Win 10 systems.
```

```
ps12bat_v2.ps1

This is modified since I noticed in dev that av started picking up the file writes to 
the startup folder. I figure it's a behavioral detection algo so that's removed in this 
version also now drops the bat bootstrap to c:\temp. Persistence is therefore broken 
still has the ability of loading a large b64 encoded file
```

```
I'm leaving ps12bat_V1 and V2 in here as not all AV behavior algos will flag it
so you're results will vary.

```

```
ps12bat_v3.ps1

This is an even more evasive modification but significantly reduces the character limit
for your script on target. The b64 encoded strings are not written to a file but to 
variables in the console session. 

Then they are concatenated and then executed so nothing else other than the bat file 
has any IO operations on the disk. I also included an example rsh.ps1 which is 
a stripped down version of the tcp version of the async client.

You can also use this as to conceal the launcher.ps1 code to decipher modded b64 strings
after downloading them using System.Net.Webclient, it does not need to be reverse shell
code. 

```
